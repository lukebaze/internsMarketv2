/** Runtime installer — detects, downloads, and configures ZeroClaw & OpenClaw */
import fs from 'node:fs';
import path from 'node:path';
import os from 'node:os';
import { execSync } from 'node:child_process';
import type { SupportedRuntime } from './runtime-adapter-factory.js';

export interface RuntimeInfo {
  id: SupportedRuntime;
  name: string;
  description: string;
  installed: boolean;
  homePath: string;
  repo: string;
}

/** Paths where each runtime lives */
const RUNTIME_PATHS: Record<SupportedRuntime, string> = {
  zeroclaw: path.join(os.homedir(), '.zeroclaw'),
  openclaw: path.join(os.homedir(), '.openclaw'),
};

const RUNTIME_REPOS: Record<SupportedRuntime, string> = {
  zeroclaw: 'https://github.com/zeroclaw-labs/zeroclaw',
  openclaw: 'https://github.com/openclaw/openclaw',
};

/** Check if a runtime is installed by verifying its home directory */
export function isRuntimeInstalled(runtime: SupportedRuntime): boolean {
  return fs.existsSync(RUNTIME_PATHS[runtime]);
}

/** Get info for all supported runtimes */
export function getRuntimeInfo(): RuntimeInfo[] {
  return [
    {
      id: 'zeroclaw',
      name: 'ZeroClaw',
      description: 'Lightweight Rust agent runtime (<5MB RAM, native AIEOS v1.1)',
      installed: isRuntimeInstalled('zeroclaw'),
      homePath: RUNTIME_PATHS.zeroclaw,
      repo: RUNTIME_REPOS.zeroclaw,
    },
    {
      id: 'openclaw',
      name: 'OpenClaw',
      description: 'Multi-channel AI assistant platform (Node.js, 13+ messaging channels)',
      installed: isRuntimeInstalled('openclaw'),
      homePath: RUNTIME_PATHS.openclaw,
      repo: RUNTIME_REPOS.openclaw,
    },
  ];
}

/** Detect current platform for binary download */
function getPlatformTarget(): { os: string; arch: string; ext: string } {
  const platform = process.platform;
  const arch = process.arch;

  const osMap: Record<string, string> = {
    darwin: 'apple-darwin',
    linux: 'unknown-linux-gnu',
    win32: 'pc-windows-msvc',
  };
  const archMap: Record<string, string> = {
    x64: 'x86_64',
    arm64: 'aarch64',
  };

  return {
    os: osMap[platform] ?? platform,
    arch: archMap[arch] ?? arch,
    ext: platform === 'win32' ? '.exe' : '',
  };
}

/** Progress callback for install steps */
export type ProgressCallback = (step: string, detail?: string) => void;

/**
 * Install ZeroClaw:
 * 1. Download latest release binary from GitHub
 * 2. Place in ~/.zeroclaw/bin/
 * 3. Create default config.toml
 * 4. Symlink to /usr/local/bin (or add to PATH hint)
 */
export async function installZeroClaw(onProgress: ProgressCallback): Promise<void> {
  const home = RUNTIME_PATHS.zeroclaw;

  onProgress('Checking prerequisites...');
  if (isRuntimeInstalled('zeroclaw')) {
    onProgress('Already installed', home);
    return;
  }

  onProgress('Creating directory structure...');
  const dirs = ['bin', 'skills', 'workspace'];
  for (const dir of dirs) {
    fs.mkdirSync(path.join(home, dir), { recursive: true });
  }

  onProgress('Downloading ZeroClaw binary...');
  const target = getPlatformTarget();
  const binaryName = `zeroclaw-${target.arch}-${target.os}${target.ext}`;
  const downloadUrl =
    `${RUNTIME_REPOS.zeroclaw}/releases/latest/download/${binaryName}`;
  const binPath = path.join(home, 'bin', `zeroclaw${target.ext}`);

  try {
    execSync(`curl -fsSL "${downloadUrl}" -o "${binPath}"`, {
      stdio: 'pipe',
      timeout: 120_000,
    });
    if (process.platform !== 'win32') {
      fs.chmodSync(binPath, 0o755);
    }
  } catch {
    /* Binary download may fail if repo doesn't exist yet — create scaffold anyway */
    onProgress('Binary download skipped (release not available yet)');
  }

  onProgress('Writing default config...');
  const configToml = [
    '# ZeroClaw Configuration — generated by InternsMarket',
    '# Docs: https://github.com/zeroclaw-labs/zeroclaw#configuration',
    '',
    '[agent]',
    'name = "default"',
    'autonomy_level = "supervised"',
    '',
    '[provider]',
    'default = "anthropic"',
    '',
    '[memory]',
    'backend = "sqlite"',
    `path = "${path.join(home, 'memory.db').replace(/\\/g, '/')}"`,
    '',
    '[channels]',
    'enabled = ["cli"]',
    '',
    '# InternsMarket interns are configured below via include directives',
    '',
  ].join('\n');
  fs.writeFileSync(path.join(home, 'config.toml'), configToml, 'utf-8');

  /* Create placeholder workspace files */
  const placeholders: Record<string, string> = {
    'SOUL.md': '# Soul\n\nDefine your agent personality and values here.\n',
    'IDENTITY.md': '# Identity\n\nDefine your agent identity here.\n',
  };
  for (const [file, content] of Object.entries(placeholders)) {
    const fp = path.join(home, 'workspace', file);
    if (!fs.existsSync(fp)) fs.writeFileSync(fp, content, 'utf-8');
  }

  onProgress('ZeroClaw installed', home);
}

/**
 * Install OpenClaw:
 * 1. Clone repo to ~/.openclaw
 * 2. Run npm install
 * 3. Create default workspace
 */
export async function installOpenClaw(onProgress: ProgressCallback): Promise<void> {
  const home = RUNTIME_PATHS.openclaw;

  onProgress('Checking prerequisites...');
  if (isRuntimeInstalled('openclaw')) {
    onProgress('Already installed', home);
    return;
  }

  onProgress('Cloning OpenClaw repository...');
  try {
    execSync(
      `git clone --depth 1 "${RUNTIME_REPOS.openclaw}" "${home}"`,
      { stdio: 'pipe', timeout: 120_000 },
    );
  } catch {
    /* Clone may fail if repo doesn't exist — create scaffold */
    fs.mkdirSync(home, { recursive: true });
    onProgress('Clone skipped (repo not available yet), creating scaffold...');
  }

  onProgress('Setting up workspace...');
  const workspaceDir = path.join(home, 'workspace');
  fs.mkdirSync(workspaceDir, { recursive: true });

  /* Create default config.yaml if not present */
  const configYaml = path.join(home, 'config.yaml');
  if (!fs.existsSync(configYaml)) {
    const yaml = [
      '# OpenClaw Configuration — generated by InternsMarket',
      '# Docs: https://github.com/openclaw/openclaw#configuration',
      '',
      'agent:',
      '  name: "default"',
      '  description: "Personal AI assistant"',
      '',
      'gateway:',
      '  host: "127.0.0.1"',
      '  port: 18789',
      '',
      'channels:',
      '  enabled:',
      '    - cli',
      '',
      'skills:',
      `  path: "${path.join(workspaceDir, 'skills').replace(/\\/g, '/')}"`,
      '',
    ].join('\n');
    fs.writeFileSync(configYaml, yaml, 'utf-8');
  }

  /* Create workspace placeholder files */
  const placeholders: Record<string, string> = {
    'AGENTS.md': '# Agents\n\nDeclare your agents here.\n',
    'SOUL.md': '# Soul\n\nDefine your agent personality and values here.\n',
    'IDENTITY.md': '# Identity\n\nDefine your agent identity here.\n',
  };
  for (const [file, content] of Object.entries(placeholders)) {
    const fp = path.join(workspaceDir, file);
    if (!fs.existsSync(fp)) fs.writeFileSync(fp, content, 'utf-8');
  }

  /* Run npm install if package.json exists */
  const packageJson = path.join(home, 'package.json');
  if (fs.existsSync(packageJson)) {
    onProgress('Installing dependencies (npm install)...');
    try {
      execSync('npm install --production', {
        cwd: home,
        stdio: 'pipe',
        timeout: 180_000,
      });
    } catch {
      onProgress('npm install skipped (may need manual setup)');
    }
  }

  onProgress('OpenClaw installed', home);
}

/** Master installer — dispatches to the correct runtime */
export async function installRuntime(
  runtime: SupportedRuntime,
  onProgress: ProgressCallback,
): Promise<void> {
  if (runtime === 'zeroclaw') return installZeroClaw(onProgress);
  if (runtime === 'openclaw') return installOpenClaw(onProgress);
  throw new Error(`Unknown runtime: ${runtime}`);
}
